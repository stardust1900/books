<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content=""><title>JAMstack博客搭建 | Jekyll 主题 Persephone</title>
  <meta name="keywords" content="JAMstack, Jekyll, Netlify CMS, 静态网页生成器, serverless, GitHub">
  <meta name="description" content="基于JAMstack搭建serverless静态博客理念及方法分享。"><link rel="stylesheet" href="/assets/main.css?v=0.3.3" />
<script src="/assets/main.js?v=0.3.3" defer></script><link rel="stylesheet" href="/assets/css/tomorrow.css" />
<script src="/assets/js/highlight.js"></script></head>
<body class="body-post">
    <a href="/" class="logo"><img src="https://erlim.oss-cn-hongkong.aliyuncs.com/img/logo.svg" class="logo_img"><h1>Jekyll 主题 Persephone</h1>
</a><main class="post__wrapper"><nav class="top-nav">

<a href="https://erl.im" class="nav-link ">叶夕青兮</a>


</nav><div class="post__top_navs clearfix">
    <nav class="post__archive_path"><a href="/blog/" id="archiveBtn">
        <div class="post__archive_icon">
          <svg width="40" height="40">
            <circle class="circle-progress" r="18" cy="20" cx="20"  stroke-linejoin="round" stroke-linecap="round" />
          </svg>
          <span class="post__archive_icon"></span>
        </div>
        博客
      </a>
    </nav>
  </div>
  <article class="post">
    <header class="post__header">
      <h1 class="post__title">JAMstack博客搭建</h1>
      <div class="post__meta">
        <time>2018-11-04 15:23</time>
      </div>
    </header>
    <div class="post__content content">
      <p>何谓JAMstack？J即JavaScript，A即APIs，M即Markup，官方解释如下：</p>

<!--more-->

<blockquote>
  <p>Modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup.</p>
</blockquote>

<p>翻译过来就是：</p>

<blockquote>
  <p>基于客户端的JavaScript，可以复用的API，及预生成的Markup的现代web开发架构。</p>
</blockquote>

<p>是近些日子流行起来的编程概念，究竟近到什么程度和流行到什么程度我就不知道了，至少在我所了解的国内web开发没有基于这种概念性架构的。但是在博客界，随着Wordpress所代表的传统cms的没落，serverless、static site generator（静态网站生成器，以下简称SSG）等概念的兴起，JAMstack也逐渐流行起来。许多人可能对JAMstack这个概念还有些生疏，但已经符合JAMstack的架构理念了。</p>

<h2 id="ssg">SSG</h2>

<p>在放弃了Wordpress之后，我首先转向了<a href="https://jekyllrb.com/">Jekyll</a>。Jekyll是最流行的SSG，它的流行与Github Pages密不可分。不论是Jekyll、Hexo或是Huge，它们都代表了JAM中的M，即Markup。</p>

<p>SSG就是通过一些约定俗成的标记和转换规则构建静态网页，耗费资源少，访问速度快，再加上Github Pages等平台的兴起使得网站可以做到serverless，引得大批程序员的青睐。</p>

<p>但SSG终究代替不了cms，因为不是每个人都是程序员。即便是我也有cms的需求。我可能随时都有灵感产生，都想写文章，或是临时发现某个错别字需要做改动，但我不会随身携带着git环境。</p>

<p>即便有这些固有的缺陷，生成器依然棒棒的，markdown也仍然棒棒的。剩下就看SSG怎么实现CMS的功能了！</p>

<h2 id="cms">CMS</h2>

<p>基于SSG的cms系统如今已经不少了，Jekyll就有一个官方的<a href="https://github.com/jekyll/jekyll-admin">JekyllAdmin</a>，不算很好用，且缺少开箱即用的登陆方案。</p>

<p>有一些第三方平台也做到了和市面上流行的SSG做无缝对接，例如Contentful和Site Leaf，但第三方平台终究不像cms，还需要从一个网站跳到另一个网站，多麻烦！且有资源量限制，超过就要收费了。</p>

<p>最后我发现了一个不算完美但非常好用的东西：<a href="https://www.netlifycms.org/">Netlifycms</a>。</p>

<p><a href="https://www.netlify.com/">Netlify</a>也是个好东西。GitPage本身有局限性，不能运行第三方插件，Netlify却可以，可以自动同步GitHub上的内容，内容有变动的时候自动 <code class="language-plaintext highlighter-rouge">build</code>，支持自定义域名，支持https。Github Pages能做到的，它都做到了；Github Pages做不到的，也都做不到了，加上Netlifycms的无缝衔接，堪称完美。</p>

<p>要说缺点只有一个：国内访问速度不稳。其实也不算很慢，比Github Pages快一些。</p>

<p>要不是我在发现它之前已经搞了个服务器，我就选定它了，也免了很多折腾（也可能因为我天生就喜欢折腾）。</p>

<p>Netlifycms是一个React构建的cms，支持包括Jekyll、Hexo等常用的SSG。它的原理是利用api同步或修改GitHub代码仓库的文件内容，同时提供了一套与GitHub账号对接的登录认证系统。基本的使用方法很简单：</p>

<p>在你的根目录下创建一个 <code class="language-plaintext highlighter-rouge">admin</code> 文件夹，新建一个 <code class="language-plaintext highlighter-rouge">index.html</code> 作为管理后台的首页，然后在这个页面引入Netlifycms的cdn文件即可。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;body&gt;</span>
      <span class="c">&lt;!-- Include the script that builds the page and powers Netlify CMS --&gt;</span>
        <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>然后在同一个文件夹下面创建一个 <code class="language-plaintext highlighter-rouge">config.yml</code> 文件，这个文件写一些必要的配置。余下的什么都不用管，Netlifycms都帮你做了。Netlifycms完全开源，你可以把源码<code class="language-plaintext highlighter-rouge">pull</code>下来自己<code class="language-plaintext highlighter-rouge">build</code>后直接扔到代码库里。不过亲测它的cdn访问速度还是很稳定的。</p>

<p>在这个过程中我遇到的最大问题是登录。Netlifycms是为Netlify准备的，它和Netlify的登录系统无缝衔接。对于不使用Netlify的人来说，就要折腾一番了。根据它的说明文档，似乎也可以使用Netlify的认证系统，不过我没太看明白。最后我是利用第三方开源的源码自己在服务器搭建了一个认证系统，也颇费了一番功夫。</p>

<p>总结下Netlifycms的原理，就是JAM中的JA：JavaScript + APIs。</p>

<p>Netlifycms的UI设计也非常漂亮，就是功能还不够灵活。可惜我不太懂React，不然有得折腾了。</p>

<p><img src="https://erlim.oss-cn-hongkong.aliyuncs.com/img/netlifycms_1.jpg" alt="Netlifycms后台主页"></p>

<p>它的Workflow功能也是个亮点，可以用于多人协作，其原理是利用GitHub的pull request功能。</p>

<p><img src="https://erlim.oss-cn-hongkong.aliyuncs.com/img/netlifycms_2.jpg" alt="Netlifycms Workflow"></p>

<p>基于<code class="language-plaintext highlighter-rouge">markdown</code>的富文本编辑器，不懂 <code class="language-plaintext highlighter-rouge">markdown </code>的人也可以使用。</p>

<p><img src="https://erlim.oss-cn-hongkong.aliyuncs.com/img/netlifycms_3.jpg" alt="Netlifycms 富文本编辑器"></p>

<h2 id="ci">CI</h2>

<p>Netlifycms是同步或更改GitHub上的内容，而我的Jekyll站是从GitHub拉到服务器再build的。那么每次更新内容的时候，还要到服务器上去pull和build，这更加麻烦了。这让我很好奇Netlify是怎么在GitHub内容变动的时候都能自动更新并部署代码的。</p>

<p>经过一番调研，发现这也没什么神奇的。要说神奇也是神奇在GitHub，Netlify只是充分利用了GitHub的功能。这里又引入了一个概念，也是没体现在JAMstack中，但与JAMstack密不可分的：Continuous Integration（持续集成，以下简称CI）。</p>

<p>CI这个概念，我是从Jekyll的官网中看到的，是Jekyll为自动化部署提供的方案。GitPage不能使用第三方插件，但第三方的CI服务可以解决这个问题，常用的包括Travis CI、CircleCI。它的原理是提供一个镜像空间，在代码仓库有变动的时候，把代码拉过去，在镜像空间里build之后再部署到GitPage。上述两个平台我都尝试过，但对于博客来说真的是大材小用了。</p>

<p>简单的办法就是利用GitHub提供的Webhooks功能，你在项目库的Settings里可以发现这个选项。当这个项目相关的事件被触发时，GitHub会向你在这个配置里添加的每一条url发送一条 <code class="language-plaintext highlighter-rouge">POST</code>请求。你可以设定让服务器在接受请求之后做你想做的事情。</p>

<p>GitHub的<a href="https://developer.github.com/webhooks/">帮助中心</a>有相关的demo，Ruby语言的，不过功能挺复杂。我这里非常简单，接受到push通知请求后，不管三七二十一，直接 <code class="language-plaintext highlighter-rouge">git pull &amp;&amp; jekyll b</code>，非常简单粗暴。按照Jekyll官网上的demo，最好先检查一下文件完整性什么的。我这个确实过于简单了，也没加认证拦截。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'json'</span>

<span class="k">class</span> <span class="nc">CIServer</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">configure</span> <span class="ss">:production</span><span class="p">,</span> <span class="ss">:development</span> <span class="k">do</span>
    <span class="n">enable</span> <span class="ss">:logging</span>
  <span class="k">end</span>

  <span class="n">post</span> <span class="s1">'/event_handler'</span> <span class="k">do</span>
    <span class="vi">@payload</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:payload</span><span class="p">])</span>

    <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"request:</span><span class="si">#{</span><span class="n">request</span><span class="p">.</span><span class="nf">env</span><span class="p">[</span><span class="s1">'HTTP_X_GITHUB_EVENT'</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>

    <span class="k">case</span> <span class="n">request</span><span class="p">.</span><span class="nf">env</span><span class="p">[</span><span class="s1">'HTTP_X_GITHUB_EVENT'</span><span class="p">]</span>
    <span class="k">when</span> <span class="s2">"push"</span>
      <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"start pulling and building"</span>
      <span class="nb">system</span> <span class="s2">"git pull; jekyll b"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="评论">评论</h2>

<p>博客怎么可能少了评论系统呢——对于这句话我当然是存疑的，因为经过了一番权衡之后，我还是放弃了评论功能——不过毕竟是折腾过的。</p>

<p>大多数基于SSG的站点想要实现评论功能，都要基于第三方工具。墙外有disqus一统天下，墙内也有多说、友言这一类的第三方评论工具。</p>

<p>我一开始就没考虑过第三方。第三方的即便用起来方便，看上去就不是自己的。和自己的博客放在一起总有些违和感。而且最关键的一点：它的评论内容与博客本身是分离的。</p>

<p>有一个叫<a href="https://staticman.net/">Staticman</a>的东西，将评论和Jekyll很好地结合在了一起。它的原理仍旧是利用API访问GitHub上的代码仓库，过程如下：</p>

<ul>
  <li>在你的博客文章页面里加一个评论提交表单，表单的<code class="language-plaintext highlighter-rouge">action</code>设置为Staticman提供的API；</li>
  <li>提交表单时，Staticman会将你的评论内容写在一个<code class="language-plaintext highlighter-rouge">yml</code>文件，并提交到你的代码仓库里；</li>
  <li>
<code class="language-plaintext highlighter-rouge">build</code>博客页面时，把对应的<code class="language-plaintext highlighter-rouge">yml</code>按照一定顺序引入即可。</li>
</ul>

<p>全部的关键就在于Staticman提供的这个接口。它不是利用你的GitHub账号，而是统一使用一个Staticman的账号，你需要先把这个账号加入的项目库的contributers里，然后在浏览器里打开下面这个url，用于让Staticman通过你的contributers申请。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://api.staticman.net/v2/connect/{your GitHub username}/{your repository name}
</code></pre></div></div>

<p>问题来了，我把contributer加好了，在n天内n次请求这个url，都返回 <code class="language-plaintext highlighter-rouge">invitation not found</code>。于是到Staticman项目库的issues里去翻，发现很多人都有这个问题，估计是请求的人太多，服务器处理不过来了。</p>

<p>于是漫长的折腾之路又开始了。我把staticman的源码拉到服务器上，自己搭建好了接口，成功了实现了评论功能。</p>

<p>然而问题又来了：我的博客是服务器持续集成的，集成需要时间。不论是请求接口还是pull还是build都不是毫秒级的。表单提交之后页面会刷新，而这时候还没<code class="language-plaintext highlighter-rouge">build</code>好呢……</p>

<p>通过异步表单可以一定程度上解决这个问题，不过我止步于此了——通过一番权衡判断，我发觉自己根本不需要评论，也不想要评论。就这个话题完全可以写满一篇文章，就不在这里陈述了。</p>

<h2 id="persephone">Persephone</h2>

<p>Jekyll这个博客我前后折腾了能有半年，至今仍未结束，折腾的天性让我不可能停止折腾的脚步。没有了wordpress，还有Jekyll；没有Jekyll还会有其他的替代品，折腾永无止境。</p>

<p>我把这个博客的项目库起名为<strong>Persephone</strong>，佩尔塞福涅，熟悉希腊神话的应该都知道，冥界主宰哈德斯（抢来的）的妻子，大名鼎鼎的冥后。</p>

<p>从Dysis开始，我自己的项目几乎都以希腊女神命名，没什么深意，只是觉得好玩儿。就好像我的折腾很多都是毫无意义的一样，只是我生活中的一部分。生活本就是毫无意义。</p>

<p>Persephone从主题到插件完全开源，有兴趣的可以自行看看：<a href="https://github.com/erlzhang/persephone">https://github.com/erlzhang/persephone</a>。我不是个优秀的程序员，有些地方可以说写得很烂，自行斟酌。至于文章和小说，好坏都是我的心血，麻烦尊重版权。</p>

    </div>
  </article><aside class="post__contact"><h4><a href="/about.html">Jekyll 主题 Persephone</a></h4>
  <p>jekyll-theme-persephone Demo演示站</p>
<div class="icon__list"><a href="mailto:zhangshiyu1992@hotmail.com" class="icon__link" target="_blank"><svg class="icon__stroke" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
  <polyline points="22,6 12,13 2,6"></polyline>
</svg>
</a><a href="https://github.com/erlzhang" class="icon__link" target="_blank"><svg viewBox="0 0 64 64" class="icon__fill">
  <path stroke-width="0" d="M32 0 C14 0 0 14 0 32 0 53 19 62 22 62 24 62 24 61 24 60 L24 55 C17 57 14 53 13 50 13 50 13 49 11 47 10 46 6 44 10 44 13 44 15 48 15 48 18 52 22 51 24 50 24 48 26 46 26 46 18 45 12 42 12 31 12 27 13 24 15 22 15 22 13 18 15 13 15 13 20 13 24 17 27 15 37 15 40 17 44 13 49 13 49 13 51 20 49 22 49 22 51 24 52 27 52 31 52 42 45 45 38 46 39 47 40 49 40 52 L40 60 C40 61 40 62 42 62 45 62 64 53 64 32 64 14 50 0 32 0 Z" />
</svg>
</a></div>
</aside>
</main><script>hljs.initHighlightingOnLoad();</script><footer class="site-footer">
  © 2024<a href="/">Jekyll 主题 Persephone</a>. Theme<a href="https://github.com/erlzhang/jekyll-theme-persephone" target="_blank">Persephone</a>
</footer>

  </body>
</html>
